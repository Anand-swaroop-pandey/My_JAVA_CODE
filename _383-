/*

Subsequence : 

> A subsequence is a sequence that can be derived from another sequence by removing zero or more elements, without changing the order of the remaining elements.
> Subsequence need not to be contigious (i.e may or may not be contigious)
> For a sequence/array/string of size n, we can have 2^n Subsequence in total i.e ((2^n)-1) non-empty sub-sequences + 1 Empty Subsequence. 
> Every Subarray is a Subequence but not every subsequence is an subarray.
> Subsequence always maintain orer of appearence.
> Subarray/Substring are always contigious and maintains order of appearence of elements while subsequence may or maynot be contigious but always maintains order of appearence of elements.
> For a sequence/array/string of size n, we can have  ( (n*(n+1))/2 + 1 ) Subarray in total i.e (n*(n+1))/2 non-empty subarray + 1 Empty subarray. 

>For example : arr[] = {1, 2, 3, 4}; there are 16 sub-sequences. 

They are 
{ } => (Subarray and subsequence)
(1) => (Subarray and subsequence)
(1,2) => (Subarray and subsequence)
(1,3) =>(Only subsequence) Reason : Its not contigious
(1,4) =>(Only subsequence) Reason : Its not contigious
(1,2,3) => (Subarray and subsequence)
(1,2,4) =>(Only subsequence) Reason : Its not contigious
(1,3,4) =>(Only subsequence) Reason : Its not contigious
(1,2,3,4) => (Subarray and subsequence)
(2) => (Subarray and subsequence)
(2,3) => (Subarray and subsequence)
(2,4) =>(Only subsequence) Reason : Its not contigious
(2,3,4) => (Subarray and subsequence)
(3) => (Subarray and subsequence)
(3,4) => (Subarray and subsequence)
(4) => (Subarray and subsequence)
*/

//Bruteforce Approach

import java.util.*;
public class Test
{
	public static void main(String[] args) {
          Scanner sc=new Scanner(System.in);
	  System.out.println("Enter the size of the array :");
	  int n=sc.nextInt();
	  if(n<=0)
	  {
	     System.out.println("Invalid Choice");
	     return;
	  }
	  
	  int[] arr=new int[n];
	  System.out.println("Enter "+n+" Elements :");
	  for(int i=0;i<n;i++)
	    arr[i]=sc.nextInt();
		 
	  allPossibleSubsequencesOrSubset(arr,n);
	}
	
	public static void allPossibleSubsequencesOrSubset(int[] arr,int n)
        {
           int powerSetSize=1<<n; // Math.pow(2,n)=1<<n (x<<y = x*(2^y))

           for(int num=0;num<powerSetSize;num++)
           {
              System.out.print("{");
          
              for(int i=0;i<n;i++)
                if(((1<<i)&num)!=0)
                  System.out.print(arr[i]+" ");
                
              System.out.println("}");
           }
	}
}

/*

Observation 1 :
Above Program will only work for array having size <=30

Reason :

Integer.MAX_VALUE=(2^31)-1 = 2147483647
Integer.MIN_VALUE= -2^31 = -2147483648

if(n==31) then 1<<31 = -2^31 = -2147483648

Possible Fix :

public static void allPossibleSubsequencesOrSubset(int[] arr,int n)
{
      long powerSetSize=(long)1<<n; // Math.pow(2,n)=1<<n (x<<y = x*(2^y))

      for(long num=0;num<powerSetSize;num++)
      {
          System.out.print("{");
          
          for(int i=0;i<n;i++)
              if(((1<<i)&num)!=0)
                System.out.print(arr[i]+" ");
                
          System.out.println("}");
      }
}
  
  But again the above program will only work for array having size <=62
  
  Reason :
  
  Long.MAX_VALUE =  2^63 -1 = 9,223,372,036,854,775,807.
  Long.MIN_VALUE = -2^63 = -9,223,372,036,854,775,808.
  
  if(n==63) then (long)1<<63 = -2^63 = -9,223,372,036,854,775,808

-------------------------------------------------------------------------------------------------------------------------------------------------------
  
Observation 2 :
  
If an Integer is bitwise left shift by more than 31 bits following pattern is observed.
  
public class Main
{
  public static void main(String[] args) {
    
    for(int i=0;i<64;i++)
    {
        int n=1<<i;
        System.out.println(n);
    }
  }
}

Output :
1
2
4
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768
65536
131072
262144
524288
1048576
2097152
4194304
8388608
16777216
33554432
67108864
134217728
268435456
536870912
1073741824
-2147483648 (Integer.MIN_VALUE)  (when i =31 i.e 1<<31)  
1 (when i =32 i.e 1<<32)
2
4
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768
65536
131072
262144
524288
1048576
2097152
4194304
8388608
16777216
33554432
67108864
134217728
268435456
536870912
1073741824
-2147483648 (Integer.MIN_VALUE) (when i =63 i.e 1<<63)
*/
